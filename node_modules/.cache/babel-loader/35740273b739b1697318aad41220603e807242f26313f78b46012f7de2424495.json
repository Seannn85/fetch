{"ast":null,"code":"import { useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { withMiddleware, useStateWithDeps, UNDEFINED, serialize, mergeObjects, getTimestamp, useIsomorphicLayoutEffect } from 'swr/_internal';\nconst mutation = () => {\n  return function (key, fetcher) {\n    let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      mutate\n    } = useSWRConfig();\n    const keyRef = useRef(key);\n    // Ditch all mutation results that happened earlier than this timestamp.\n    const ditchMutationsUntilRef = useRef(0);\n    const [stateRef, stateDependencies, setState] = useStateWithDeps({\n      data: UNDEFINED,\n      error: UNDEFINED,\n      isMutating: false\n    });\n    const currentState = stateRef.current;\n    const trigger = useCallback(async (arg, opts) => {\n      const [serializedKey, resolvedKey] = serialize(keyRef.current);\n      if (!fetcher) {\n        throw new Error('Can’t trigger the mutation: missing fetcher.');\n      }\n      if (!serializedKey) {\n        throw new Error('Can’t trigger the mutation: missing key.');\n      }\n      // Disable cache population by default.\n      const options = mergeObjects(mergeObjects({\n        populateCache: false,\n        throwOnError: true\n      }, config), opts);\n      // Trigger a mutation, and also track the timestamp. Any mutation that happened\n      // earlier this timestamp should be ignored.\n      const mutationStartedAt = getTimestamp();\n      ditchMutationsUntilRef.current = mutationStartedAt;\n      setState({\n        isMutating: true\n      });\n      try {\n        const data = await mutate(serializedKey, fetcher(resolvedKey, {\n          arg\n        }),\n        // We must throw the error here so we can catch and update the states.\n        mergeObjects(options, {\n          throwOnError: true\n        }));\n        // If it's reset after the mutation, we don't broadcast any state change.\n        if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n          setState({\n            data,\n            isMutating: false,\n            error: undefined\n          });\n          options.onSuccess == null ? void 0 : options.onSuccess(data, serializedKey, options);\n        }\n        return data;\n      } catch (error) {\n        // If it's reset after the mutation, we don't broadcast any state change\n        // or throw because it's discarded.\n        if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n          setState({\n            error: error,\n            isMutating: false\n          });\n          options.onError == null ? void 0 : options.onError(error, serializedKey, options);\n          if (options.throwOnError) {\n            throw error;\n          }\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    const reset = useCallback(() => {\n      ditchMutationsUntilRef.current = getTimestamp();\n      setState({\n        data: UNDEFINED,\n        error: UNDEFINED,\n        isMutating: false\n      });\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useIsomorphicLayoutEffect(() => {\n      keyRef.current = key;\n    });\n    // We don't return `mutate` here as it can be pretty confusing (e.g. people\n    // calling `mutate` but they actually mean `trigger`).\n    // And also, `mutate` relies on the useSWR hook to exist too.\n    return {\n      trigger,\n      reset,\n      get data() {\n        stateDependencies.data = true;\n        return currentState.data;\n      },\n      get error() {\n        stateDependencies.error = true;\n        return currentState.error;\n      },\n      get isMutating() {\n        stateDependencies.isMutating = true;\n        return currentState.isMutating;\n      }\n    };\n  };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */\nvar index = withMiddleware(useSWR, mutation);\nexport { index as default };","map":{"version":3,"names":["useRef","useCallback","useSWR","useSWRConfig","withMiddleware","useStateWithDeps","UNDEFINED","serialize","mergeObjects","getTimestamp","useIsomorphicLayoutEffect","mutation","key","fetcher","config","mutate","keyRef","ditchMutationsUntilRef","stateRef","stateDependencies","setState","data","error","isMutating","currentState","current","trigger","arg","opts","serializedKey","resolvedKey","Error","options","populateCache","throwOnError","mutationStartedAt","undefined","onSuccess","onError","reset","index","default"],"sources":["/Users/goktugkoyun/Desktop/Projects/fetch/node_modules/swr/mutation/dist/index.mjs"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from 'swr';\nimport { withMiddleware, useStateWithDeps, UNDEFINED, serialize, mergeObjects, getTimestamp, useIsomorphicLayoutEffect } from 'swr/_internal';\n\nconst mutation = ()=>{\n    return (key, fetcher, config = {})=>{\n        const { mutate  } = useSWRConfig();\n        const keyRef = useRef(key);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcher) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, config), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcher(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    setState({\n                        data,\n                        isMutating: false,\n                        error: undefined\n                    });\n                    options.onSuccess == null ? void 0 : options.onSuccess(data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    setState({\n                        error: error,\n                        isMutating: false\n                    });\n                    options.onError == null ? void 0 : options.onError(error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ var index = withMiddleware(useSWR, mutation);\n\nexport { index as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}